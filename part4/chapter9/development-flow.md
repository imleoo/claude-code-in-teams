# AI协作开发全流程示例

理论已经完备，文档已经就绪。本节将以一个具体的任务——“实现聊天消息流界面”——为例，完整地展示从需求分析到最终交付的全流程，让你身临其境地感受“团队Vibe Coding”的协作脉搏。

---

### **第一周：需求分析与架构设计**

#### **Day 1: AI协作需求澄清**

产品经理陈晨完成了PRD初稿后，她没有直接召开评审会，而是先让AI进行第一轮“体检”。

**陈晨的Prompt:**
> 你是一位资深的产品总监。请审查这份RAG聊天机器人的PRD文档 (`docs/01_Requirements/PRD-RAG-Chatbot.md`)。
>
> 请重点分析：
> 1.  **需求模糊点**：哪些功能的描述不够清晰，可能会导致开发者的误解？
> 2.  **遗漏的边缘场景**：我们是否忽略了某些用户可能遇到的边缘情况？（例如：网络断开、上传超大文件、输入恶意代码等）
> 3.  **用户故事优化**：将PRD中的功能需求，转化为更具共情力的、符合INVEST原则的用户故事。

AI的输出帮助陈晨在正式评审前，就完善了文档，识别出“消息加载失败时的重试机制”、“用户输入内容的长度限制”等多个被忽略的细节。

#### **Day 3: AI协作技术选型**

在技术选型阶段，团队对向量数据库的选择产生了讨论：是使用`pgvector`还是专门的向量数据库如`Milvus`？

AI工程师王浩利用AI快速生成了一份决策依据。

**王浩的Prompt:**
> 我们正在为一个低风险的内部RAG项目进行技术选型。请为我们对比`PostgreSQL + pgvector`方案与`Milvus`独立部署方案的优劣。
>
> 对比维度请包括：
> - 部署与运维复杂度
> - 性能（写入与查询）
> - 生态系统与集成便利性
> - 成本
> - 技术成熟度与社区支持
>
> 最后，请基于我们“低风险、快速迭代、简化运维”的项目背景，给出一个明确的选型建议。

AI生成的详细对比表格，让团队在半小时内就达成了共识：在当前阶段，`pgvector`的轻量和易于集成是最佳选择。这个决策过程被记录到了`docs/05_ADR/`中。

---

### **第二周：并行开发**

#### **Day 6: Worktree设置与任务启动**

开发正式开始。前端工程师李雪领到了“开发聊天界面”的任务。她首先为自己的任务创建了一个独立的worktree。

```bash
# 李雪在她的终端中执行
git worktree add ../rag-bot-frontend-chat-ui feature/frontend-chat-ui
cd ../rag-bot-frontend-chat-ui
npm install
code . # 在新的VS Code窗口中打开
```

#### **Day 7: AI驱动的前端组件开发**

李雪打开了新的VS Code窗口，开始了她的AI协作开发之旅。

**李雪的Prompt:**
> 你是一位精通React和TypeScript的前端专家。
>
> **项目信息**：
> (粘贴 `docs/00_Project_Info/CLAUDE.md` 的内容)
>
> **任务**：
> 请为我创建一个聊天消息流组件 `ChatMessageStream.tsx`。
>
> **设计稿与API规范**：
> - 设计要求请参考 `docs/01_Requirements/PRD-RAG-Chatbot.md` 中的界面描述。
> - API数据结构请遵循 `docs/03_API_Design/openapi.v1.yaml` 中定义的 `ChatMessage` 模型。
>
> **具体要求**：
> 1.  组件能渲染一个消息列表，区分用户消息和机器人消息，并显示在不同侧。
> 2.  机器人消息需要包含可点击的“来源文档”链接。
> 3.  当消息正在加载时，显示一个loading动画。
> 4.  代码需要包含完整的JSDoc注释，并使用Tailwind CSS进行样式设计。

几分钟后，AI生成了包含完整代码、样式和注释的组件文件。李雪的工作从“从零编写”变为了“审查和微调”。

#### **Day 8: AI生成单元测试**

组件完成后，李雪立即让AI为其编写单元测试。

**李雪的Prompt:**
> 这是我刚刚完成的 `ChatMessageStream.tsx` 组件。
>
> (粘贴组件代码)
>
> 请为它编写一套完整的单元测试，使用`@testing-library/react`和`jest`。
>
> 必须覆盖以下场景：
> 1.  正确渲染用户消息和机器人消息。
> 2.  机器人消息的来源文档链接可以被正确渲染。
> 3.  当`isLoading` prop为`true`时，loading动画被正确显示。
> 4.  当消息列表为空时，显示一个“欢迎语”。

AI生成的测试文件，让李雪在几分钟内就获得了超过90%的测试覆盖率。

---

### **第三周：集成与质量保证**

#### **Day 11: AI增强的代码审查**

李雪完成了整个聊天功能的开发，提交了Pull Request。CI流水线自动触发了AI预审查。

**AI审查员自动评论在PR中：**
> **🤖 AI Review Bot:**
>
> - **✅ 代码风格**: 通过。
> - **⚠️ 性能建议**: 在 `ChatMessageStream.tsx` 的第45行，`messages.map` 函数的key使用了数组索引 `index`。在列表可能发生变化时，这可能导致不必要的重渲染。建议使用消息的唯一ID `message.id` 作为key。
> - **💡 逻辑简化**: 在 `useChat.ts` hook中，处理消息状态的逻辑可以被一个`useReducer`替代，以获得更可预测的状态管理。是否需要我提供一个重构示例？

后端工程师张伟作为人类审查者，看到了AI的评论。他无需再关心代码风格和基础性能问题，而是将注意力集中在业务逻辑上。

**张伟的评论：**
> “整体看起来很棒！AI的建议很有价值。另外，业务逻辑上，当用户连续快速发送多条消息时，我们需要在UI上做一个队列或者禁用发送按钮，防止API调用拥堵。这个逻辑需要在 `useChat.ts` 中补充一下。”

#### **Day 13: AI生成E2E测试**

所有功能模块都已合并到`develop`分支。产品经理陈晨准备进行验收测试。在此之前，她让AI先根据核心用户故事生成E2E测试脚本。

**陈晨的Prompt:**
> 你是Playwright专家。请根据我们的核心用户故事，生成一个E2E测试脚本。
>
> **用户故事**: “用户进入应用，上传一份PDF文档，等待处理完成后，针对该文档内容进行提问，并能得到包含来源的回答。”
>
> 请将这个流程翻译为Playwright测试代码。

这个自动化的E2E测试，成为了每次发布前的“冒烟测试”，确保了核心链路的稳定。

---

**本节小结：** 这个流程生动地展示了“团队Vibe Coding”的日常。AI不再是一个简单的代码补全工具，而是深度融入了需求分析、技术设计、编码、测试、审查等每一个环节，成为了团队的“超级成员”。它极大地提升了单点任务的效率，更重要的是，它通过标准化的文档和流程，成为了连接不同角色、不同任务的“润滑剂”，让整个团队的协作如丝般顺滑。

**下一章预告：** [第9章 电商数据仪表盘重构案例（中风险）](part4/chapter9.md)